import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Main {

    /*
     * Here's a summary of the meaning of each variable:
     * 
     * - `NUM_OF_PAGES`: This variable represents the total number of pages in the
     * system. It indicates the size of the page pool or the number of unique pages
     * that can be requested.
     * 
     * - `NUM_OF_FRAMES`: This variable represents the total number of frames
     * available in the system. Frames are allocated in main memory to store the
     * pages that are currently in use.
     * 
     * - `NUM_OF_REQUESTS`: This variable represents the total number of page
     * requests that will be generated by the `Generator`. It indicates the number
     * of times a page will be requested during the execution of the algorithm.
     * 
     * - `MAX_LOCAL_SUBSET_SIZE`: This variable represents the maximum size of the
     * local subset for the `Generator`. The local subset is a subset of pages
     * randomly selected from the page pool, and this variable defines the maximum
     * number of pages that can be included in this subset.
     * 
     * - `LOCAL_PROBABILITY`: This variable represents the probability of generating
     * a request from the local subset instead of the entire page pool. It
     * determines the likelihood of a request being made for a page from the local
     * subset.
     * 
     * - `MAX_LOCAL_AMOUNT`: This variable represents the maximum number of local
     * requests that can be made consecutively before switching back to global
     * requests. It sets an upper limit on the number of consecutive requests that
     * can be made from the local subset before diversifying the requests to the
     * entire page pool.
     * 
     * These variables are used in the generation of page requests by the
     * `Generator` and are relevant to the page replacement algorithm being
     * implemented in the code.
     */

    private static int NUM_OF_PAGES = 100;
    private static int NUM_OF_FRAMES = 10;

    private static int NUM_OF_REQUESTS = 20;
    private static int MAX_LOCAL_SUBSET_SIZE = 50;
    private static double LOCAL_PROBABILITY = 0.05;
    private static int MAX_LOCAL_AMOUNT = 500;

    private static int fifoFaults;
    private static int optFaults;
    private static int lruFaults;
    private static int alruFaults;
    private static int ranFaults;

    private static List<Integer> requests = new ArrayList<>();

    public static void main(String[] args) {

        generateRequests(NUM_OF_PAGES, NUM_OF_FRAMES);

        runAlgorithms();

        displayData();

        printFaultsGraph();

        rankAlgorithms();
    }

    private static void generateRequests(int numberOfPages, int numberOfFrames) {
        requests = Generator.generate(numberOfPages, NUM_OF_REQUESTS, MAX_LOCAL_SUBSET_SIZE, LOCAL_PROBABILITY,
                MAX_LOCAL_AMOUNT);
    }

    /**
     * 1. FIFO (First-In, First-Out):
     * - FIFO is a page replacement algorithm that evicts the oldest page in the
     * memory when a new page needs to be loaded.
     * - It follows the principle of "first come, first served" and treats the pages
     * as a queue, where the page at the front is the oldest.
     * - This algorithm does not consider the frequency of page usage or the
     * relevance of pages to the current workload.
     * 
     * 2. OPT (Optimal):
     * - OPT is an optimal page replacement algorithm that aims to minimize the
     * number of page faults by replacing the page that will not be used for the
     * longest duration in the future.
     * - It requires having future knowledge of page references, which is usually
     * not feasible in practical scenarios.
     * - OPT is often used as a benchmark to compare the performance of other
     * algorithms.
     * 
     * 3. LRU (Least Recently Used):
     * - LRU is a page replacement algorithm that evicts the page that has not been
     * used for the longest period of time.
     * - It assumes that pages that have not been used recently are less likely to
     * be used in the near future.
     * - LRU requires maintaining a record of the order in which pages are accessed,
     * which can be done using a data structure such as a linked list or a priority
     * queue.
     * 
     * 4. ALRU (Adaptive Least Recently Used):
     * - ALRU is an enhancement of the LRU algorithm that dynamically adjusts the
     * eviction decisions based on the observed behavior of pages.
     * - It assigns each page a reference bit that indicates whether the page has
     * been referenced since the last time the algorithm checked it.
     * - When a page needs to be replaced, ALRU considers both the age and the
     * reference bit to make an informed decision.
     * 
     * 5. RAND (Random):
     * - RAND is a page replacement algorithm that randomly selects a page to evict
     * when a new page needs to be loaded.
     * - It does not take into account any historical information or patterns of
     * page usage.
     * - Random eviction can result in a higher number of page faults compared to
     * other algorithms that make eviction decisions based on usage patterns.
     */

    private static void runAlgorithms() {
        FIFO fifo = new FIFO();
        OPT opt = new OPT();
        LRU lru = new LRU();
        ALRU alru = new ALRU();
        RandomReplacement rand = new RandomReplacement();

        fifoFaults = fifo.run(NUM_OF_PAGES, NUM_OF_FRAMES, requests);
        optFaults = opt.run(NUM_OF_PAGES, NUM_OF_FRAMES, requests);
        lruFaults = lru.run(NUM_OF_PAGES, NUM_OF_FRAMES, requests);
        alruFaults = alru.run(NUM_OF_PAGES, NUM_OF_FRAMES, requests);
        ranFaults = rand.run(NUM_OF_PAGES, NUM_OF_FRAMES, requests);
    }

    private static void displayData() {
        System.out.println("Simulation data:");
        System.out.println("Number of pages: " + NUM_OF_PAGES);
        System.out.println("Number of frames: " + NUM_OF_FRAMES);
        System.out.println("Number of requests: " + requests.size());

        System.out.println("\nNumber of faults:");
        System.out.printf("%15s%n", "FIFO: " + fifoFaults);
        System.out.printf("%15s%n", "OPT: " + optFaults);
        System.out.printf("%15s%n", "LRU: " + lruFaults);
        System.out.printf("%15s%n", "ALRU: " + alruFaults);
        System.out.printf("%15s%n", "RAN: " + ranFaults);
    }

    private static void printFaultsGraph() {
        int[] faults = { fifoFaults, optFaults, lruFaults, alruFaults, ranFaults };
        String[] algorithms = { "FIFO", "OPT", "LRU", "ALRU", "RAN" };

        int maxFaults = Arrays.stream(faults).max().orElse(0);
        int maxLength = 20; // Maximum bar length

        System.out.println("\nFaults Comparison:");

        for (int i = 0; i < algorithms.length; i++) {
            int scaledLength = (int) ((double) faults[i] / maxFaults * maxLength);
            String bar = "*".repeat(scaledLength);
            System.out.printf("%-5s %s%n", algorithms[i], bar);
        }
    }

    private static void rankAlgorithms() {
        Map<String, Integer> algorithmFaults = new HashMap<>();
        algorithmFaults.put("FIFO", fifoFaults);
        algorithmFaults.put("OPT", optFaults);
        algorithmFaults.put("LRU", lruFaults);
        algorithmFaults.put("ALRU", alruFaults);
        algorithmFaults.put("RAN", ranFaults);

        List<Map.Entry<String, Integer>> sortedFaults = new ArrayList<>(algorithmFaults.entrySet());
        sortedFaults.sort(Map.Entry.comparingByValue());

        System.out.println("\nAlgorithm Rankings (worst-to-best):");

        int rank = 1;
        for (int i = sortedFaults.size() - 1; i >= 0; i--) {
            String algorithm = sortedFaults.get(i).getKey();
            int faults = sortedFaults.get(i).getValue();

            System.out.printf("%d. %-5s - Faults: %d%n", rank++, algorithm, faults);
        }
    }
}
